{"version":3,"file":"factory-builder.js","sources":["../src/utils.js","../src/build.js","../src/FactoryBuilder.js","../src/buildList.js","../index.js"],"sourcesContent":["/**\n * The `isObject` is an internal method that checks whether a given item is a\n * real object or not.\n * @param {Object} item - The object we want to check for being an object\n * @returns {Boolean} - The result of the check for an object\n */\n\nexport const isObject = item => typeof item === 'object' && !Array.isArray(item) && item !== null;\n\n/**\n * The `isFunction` is an internal method to verify whether the passed item is\n * a function or not.\n * @param {Object} item - The object we want to check for being a function\n * @returns {Boolean} - The result of the check for a function\n */\n\nconst isFunction = item => !!(item && item.constructor && item.call && item.apply);\n\n/**\n * The `attributesFor` is a helper method that retrieves the attributes\n * from a factory instance. If none are found, it raises a helpful error\n * message.\n * @param {Object|Function} Factory - The factory or an instance of the factory\n * @param {String} - The variant for a factory\n * @returns {Object} - The attributes of the factory\n */\n\nexport const attributesFor = (Factory, as = undefined) => {\n  // It's possible to pass a instance that is not initiate yet to this method\n  // too. The internal methods will instanciate the, but when you use it directly\n  // it's also possible to use the uninstanciated variant directly.\n  const factoryInstance = isFunction(Factory) ? new Factory() : Factory;\n\n  // Now we will check whether the factory has implemented the `attributes` key\n  // or function. When that is not the case, we will ask the developer to implement this.\n  if (factoryInstance.attributes) {\n    // Get the base attributes for the factory. After this we can check for the variant.\n    const baseAttributes = isObject(factoryInstance.attributes)\n      ? factoryInstance.attributes\n      : factoryInstance.attributes();\n\n    // When the `as` param is undefined, we just return the base attributes. When\n    // the `as` param is defined, we want to merge the base attributes with the\n    // attributes of the variant.\n    if (!as) return baseAttributes;\n    return { ...baseAttributes, ...factoryInstance.variants[as] };\n  }\n\n  throw new Error(\n    'Every factory needs some sensible defaults. So please implement the ' +\n      'attributes method/key on the factory yourself.',\n  );\n};\n\n/**\n * The `checkHookForReturnValue` double checks whether a before/after hook\n * really returned an object.\n * @param {Object} hookResult - The result of the hook\n * @param {String} hookName - The name of the hook that is being called\n */\n\nexport const checkHookForReturnValue = (hookResult, hookName) => {\n  if (hookResult && isObject(hookResult)) return;\n\n  throw new Error(\n    `The ${hookName} needs to return the factory data otherwise ` +\n      `we can't proceed in building/creating the factory.`,\n  );\n};\n\n/**\n * The `checkHookForFunction` validates whether the hook we want to execute\n * is actually a function. When it's not a function, we can't update the data\n * correctly, so we want to enforce the hook to be a function.\n * @param {Object} factory - The factory we want to build/create\n * @param {String} hookName - The name of the hook that is being called\n */\nexport const checkHookForFunction = (factory, hookName) => {\n  if (isFunction(factory[hookName])) return;\n\n  throw new Error(\n    `The ${hookName} is not a function. In order to work with hooks, you should ` +\n      `make the ${hookName} a function.`,\n  );\n};\n\n/**\n * The `checkForUnkownAttributes` method checks whether a developer is\n * adding attributes to the factory that are not on the base factory. When\n * this happens, we're raising an error message.\n * @param {Object} factory - The instance of the factory\n * @param {Object} attributes - The attributes that will be added to the factory\n */\n\nexport const checkForUnknownAttributes = (factory, attributes) => {\n  const factoryAttributes = Object.keys(attributesFor(factory));\n  const whitelistedAttributes = ['id', 'createdAt', 'updatedAt'];\n\n  // We check for none existing attributes, because we don't want to assign\n  // attributes that are not defined on the factory. We also check the\n  // whitelisted attributes to make sure the developer can set these when\n  // building or creating a new factory.\n  const unknownAttributes = Object.keys(attributes).filter(\n    key => !factoryAttributes.includes(key) && !whitelistedAttributes.includes(key),\n  );\n\n  // When there are unknown attributes, we raise an error that tells\n  // the developer which attributes are added, that are not present on\n  // the factory itself.\n  if (unknownAttributes.length) {\n    throw new Error(\n      `\"${unknownAttributes.join(', ')}\" is/are not defined on the factory itself. ` +\n        `Please add these to the factory to be able to use them and clear this message.`,\n    );\n  }\n};\n\n/**\n * The `randomNumber` helper function generates a random number between\n * a certain range.\n * @param {Integer} min - The minimal number\n * @param {Integer} max - The maximal number\n * @returns {Integer} - A randomly generated number\n */\n\nexport const randomNumber = (min = 1, max = 1000) =>\n  Math.floor(Math.random() * (max - min + 1)) + min;\n","import {\n  attributesFor,\n  checkHookForReturnValue,\n  checkForUnknownAttributes,\n  isObject,\n  checkHookForFunction,\n} from './utils';\n\nconst build = (factory, parameters = {}) => {\n  const { as, skipHooks, ...attributes } = parameters;\n\n  // The factory should be a simple object. When it's not, we will reject it from\n  // being processed.\n  if (!isObject(factory)) {\n    throw new Error(\n      'Every factory needs to be an object. Please implement this new way of defining ' +\n        'your factories to keep using Factory Builder.',\n    );\n  }\n\n  // Check whether the given attributes are known to the instance\n  checkForUnknownAttributes(factory, attributes);\n\n  // Let's start building this factory by merging the default attributes\n  // of the factory with the given attributes that should override it\n  const baseAttributes = attributesFor(factory, as);\n  let factoryBuild = { ...baseAttributes, ...attributes };\n\n  // Before we start building the factory, we want to give the developer\n  // some extra options to modify the data as they wish. This is the place\n  // where they can still add data to the factory.\n  if (factory.beforeBuild && !skipHooks) {\n    checkHookForFunction(factory, 'beforeBuild');\n    factoryBuild = factory.beforeBuild(factoryBuild);\n    checkHookForReturnValue(factoryBuild, 'beforeBuild');\n  }\n\n  // Now, we're actually building the factory by remove the ID and\n  // the timestamps (createdAt and updatedAt) from the factory if they're\n  // even present.\n  \n  // WHY!?\n  // const { id, createdAt, updatedAt, ...restProps } = factoryBuild;\n  // factoryBuild = restProps;\n\n  // Just before we return it, we want to pass the data back to\n  // the developer so they can use the newly build data and maybe\n  // add some extra's here.\n  if (factory.afterBuild && !skipHooks) {\n    checkHookForFunction(factory, 'afterBuild');\n    factoryBuild = factory.afterBuild(factoryBuild);\n    checkHookForReturnValue(factoryBuild, 'afterBuild');\n  }\n\n  return factoryBuild;\n};\n\nexport default build;\n","import build from './build';\nimport buildList from './buildList';\nimport { attributesFor } from './utils';\n\nconst FactoryBuilder = {\n  build,\n  buildList,\n  attributesFor,\n};\n\nexport default FactoryBuilder;\nexport { build, buildList, attributesFor };\n","import build from './build';\n\nconst buildList = (factory, count = 2, parameters = {}) =>\n  new Array(count).fill().map(() => build(factory, parameters));\n\nexport default buildList;\n","const FactoryBuilder = require('./src/FactoryBuilder');\n\nmodule.exports = FactoryBuilder.default || FactoryBuilder;\n"],"names":["isObject","item","_typeof","Array","isArray","isFunction","constructor","call","apply","attributesFor","Factory","as","undefined","factoryInstance","attributes","baseAttributes","variants","Error","checkHookForReturnValue","hookResult","hookName","checkHookForFunction","factory","checkForUnknownAttributes","factoryAttributes","Object","keys","whitelistedAttributes","unknownAttributes","filter","key","includes","length","join","build","parameters","skipHooks","factoryBuild","beforeBuild","afterBuild","FactoryBuilder","buildList","count","fill","map"],"mappings":"6xCAOO,IAAMA,EAAW,SAAAC,SAAwB,WAAhBC,EAAOD,KAAsBE,MAAMC,QAAQH,IAAkB,OAATA,GAS9EI,EAAa,SAAAJ,YAAWA,GAAQA,EAAKK,aAAeL,EAAKM,MAAQN,EAAKO,QAW/DC,EAAgB,SAACC,OAASC,8DAAKC,EAIpCC,EAAkBR,EAAWK,GAAW,IAAIA,EAAYA,KAI1DG,EAAgBC,WAAY,KAExBC,EAAiBf,EAASa,EAAgBC,YAC5CD,EAAgBC,WAChBD,EAAgBC,oBAKfH,SACOI,GAAmBF,EAAgBG,SAASL,IADxCI,QAIZ,IAAIE,MACR,uHAYSC,EAA0B,SAACC,EAAYC,OAC9CD,IAAcnB,EAASmB,SAErB,IAAIF,MACR,cAAOG,yGAYEC,EAAuB,SAACC,EAASF,OACxCf,EAAWiB,EAAQF,UAEjB,IAAIH,MACR,cAAOG,qFACOA,oBAYLG,EAA4B,SAACD,EAASR,OAC3CU,EAAoBC,OAAOC,KAAKjB,EAAca,IAC9CK,EAAwB,CAAC,KAAM,YAAa,aAM5CC,EAAoBH,OAAOC,KAAKZ,GAAYe,QAChD,SAAAC,UAAQN,EAAkBO,SAASD,KAASH,EAAsBI,SAASD,SAMzEF,EAAkBI,aACd,IAAIf,MACR,WAAIW,EAAkBK,KAAK,yICvG3BC,EAAQ,SAACZ,OAASa,yDAAa,GAC3BxB,EAAiCwB,EAAjCxB,GAAIyB,EAA6BD,EAA7BC,UAActB,IAAeqB,0BAIpCnC,EAASsB,SACN,IAAIL,MACR,gIAMJM,EAA0BD,EAASR,OAI7BC,EAAiBN,EAAca,EAASX,GAC1C0B,SAAoBtB,GAAmBD,UAKvCQ,EAAQgB,cAAgBF,IAC1Bf,EAAqBC,EAAS,eAC9Be,EAAef,EAAQgB,YAAYD,GACnCnB,EAAwBmB,EAAc,gBAcpCf,EAAQiB,aAAeH,IACzBf,EAAqBC,EAAS,cAC9Be,EAAef,EAAQiB,WAAWF,GAClCnB,EAAwBmB,EAAc,eAGjCA,GClDHG,EAAiB,CACrBN,MAAAA,EACAO,UCJgB,SAACnB,OAASoB,yDAAQ,EAAGP,yDAAa,UAClD,IAAIhC,MAAMuC,GAAOC,OAAOC,KAAI,kBAAMV,EAAMZ,EAASa,ODIjD1B,cAAAA,KELe+B,WAA0BA"}